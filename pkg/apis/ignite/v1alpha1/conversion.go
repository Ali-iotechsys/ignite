package v1alpha1

import (
	"github.com/weaveworks/ignite/pkg/apis/ignite"
	meta "github.com/weaveworks/ignite/pkg/apis/meta/v1alpha1"
	"k8s.io/apimachinery/pkg/conversion"
)

// Convert_ignite_VMSpec_To_v1alpha1_VMSpec calls the autogenerated conversion function along with custom conversion logic
func Convert_ignite_VMSpec_To_v1alpha1_VMSpec(in *ignite.VMSpec, out *VMSpec, s conversion.Scope) error {
	// VMSpecStorage are not supported by v1alpha1, so just ignore the warning by calling this manually
	return autoConvert_ignite_VMSpec_To_v1alpha1_VMSpec(in, out, s)
}

// Convert_ignite_VMSpec_To_v1alpha1_VMSpec calls the autogenerated conversion function along with custom conversion logic
func Convert_v1alpha1_VMSpec_To_ignite_VMSpec(in *VMSpec, out *ignite.VMSpec, s conversion.Scope) error {
	// VMSpecStorage is not supported by v1alpha1, so just ignore the warning by calling this manually
	return autoConvert_v1alpha1_VMSpec_To_ignite_VMSpec(in, out, s)
}

// Convert_ignite_VMStatus_To_v1alpha1_VMStatus calls the autogenerated conversion function along with custom conversion logic
func Convert_ignite_VMStatus_To_v1alpha1_VMStatus(in *ignite.VMStatus, out *VMStatus, s conversion.Scope) error {
	if err := autoConvert_ignite_VMStatus_To_v1alpha1_VMStatus(in, out, s); err != nil {
		return err
	}

	// Convert in.Running to out.State
	if in.Running {
		out.State = VMStateRunning
	} else {
		out.State = VMStateStopped
	}

	return nil
}

// Convert_v1alpha1_VMStatus_To_ignite_VMStatus calls the autogenerated conversion function along with custom conversion logic
func Convert_v1alpha1_VMStatus_To_ignite_VMStatus(in *VMStatus, out *ignite.VMStatus, s conversion.Scope) error {
	if err := autoConvert_v1alpha1_VMStatus_To_ignite_VMStatus(in, out, s); err != nil {
		return err
	}

	// Convert in.State to out.Running
	out.Running = in.State == VMStateRunning

	return nil
}

// Convert_ignite_OCIImageSource_To_v1alpha1_OCIImageSource calls the autogenerated conversion function along with custom conversion logic
func Convert_ignite_OCIImageSource_To_v1alpha1_OCIImageSource(in *ignite.OCIImageSource, out *OCIImageSource, s conversion.Scope) error {
	if err := autoConvert_ignite_OCIImageSource_To_v1alpha1_OCIImageSource(in, out, s); err != nil {
		return err
	}

	// If the OCI content ID is local, i.e. not available from a repository,
	// populate the ID field of v1alpha1.OCIImageSource. Otherwise add the
	// the repo digest of the ID as the only digest for v1alpha1.
	if in.ID.Local() {
		out.ID = in.ID.Digest()
	} else {
		out.RepoDigests = []string{in.ID.RepoDigest()}
	}

	return nil
}

// Convert_v1alpha1_OCIImageSource_To_ignite_OCIImageSource calls the autogenerated conversion function along with custom conversion logic
func Convert_v1alpha1_OCIImageSource_To_ignite_OCIImageSource(in *OCIImageSource, out *ignite.OCIImageSource, s conversion.Scope) (err error) {
	if err = autoConvert_v1alpha1_OCIImageSource_To_ignite_OCIImageSource(in, out, s); err != nil {
		return err
	}

	// By default parse the OCI content ID from the Docker image ID
	contentRef := in.ID
	if len(in.RepoDigests) > 0 {
		// If the image has Repo digests, use the first one of them to parse
		// the fully qualified OCI image name and digest. All of the digests
		// point to the same contents, so it doesn't matter which one we use
		// here. It will be translated to the right content by the runtime.
		contentRef = in.RepoDigests[0]
	}

	// Parse the OCI content ID based on the available reference
	out.ID, err = meta.ParseOCIContentID(contentRef)
	return
}
